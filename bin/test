#!/usr/bin/env bash
: <<'COPYRIGHT'
 Copyright (c) Vaimo Group. All rights reserved.
 See LICENSE_VAIMO.txt for license details.
COPYRIGHT

### Color shortcuts for echoed color output ###
txtrst=$(tput sgr0)         # Reset color/styling
txtund=$(tput sgr 0 1)      # Underline
txtbld=$(tput bold)         # Bold
red=$(tput setaf 9)         # bright red
drkred=$(tput setaf 1)      # dark red
drkmag=$(tput setaf 5)      # dark magenta
grn=$(tput setaf 2)         # dark green
brghtgrn=$(tput setaf 10)   # bright green
brghtcya=$(tput setaf 14)   # bright cyan
dkylw=$(tput setaf 3)       # dark yellow
yel=$(tput setaf 11)        # yellow
gry=$(tput setaf 7)         # grey (default terminal grey)
dgry=$(tput setaf 8)        # dark grey
blu=$(tput setaf 12)        # blue
mag=$(tput setaf 13)        # magenta
cya=$(tput setaf 6)         # cyan
wht=$(tput setaf 15)        # white
bldred=${txtbld}${red}      # bold-red
bldgrn=${txtbld}${grn}      # bold-green
bldyel=${txtbld}${yel}      # bold-yellow
bldblu=${txtbld}${blu}      # bold-blue
bldwht=${txtbld}${wht}      # bold-white
bgdred=$(tput setab 1)      # dark red background
bldcya=${txtbld}${cya}      # bold-cya
bgdblu=$(tput setab 4)      # dark blue background
bgdgrn=$(tput setab 2)      # green background
bgdylw=$(tput setab 3)      # dark yellow background
bgcol=$(tput sgr 1 0)       # Switch to background (coloring mode)
fgcol=$(tput sgr 0 0)       # Switch to foreground (coloring mode)

function run_tests() {
    scenario_root=${1}
        
    scenario_label=$(cat ${scenario_root}/.label)
    commands=$(cat ${scenario_root}/.commands)
        
    _line '-' 80
    _info "SCENARIO:" "${scenario}" "${scenario_label}"
    _line '-' 80
            
    rm -rf patches 2>/dev/null
    rm patches.json 2>/dev/null
    
    local original_ifs=${IFS}
    IFS=$'\n'
    
    for dependency in $(ls -1 ${scenario_root}/files) ; do
        ln -s ${scenario_root}/files/${dependency} ${dependency}
    done 
        
    local should_fail
    
    for command in ${commands} ; do
        should_fail=0
        
        if [ "${command:0:1}" == "!" ] ; then
            _warning "EXPECTING FAILURE"
            should_fail=1
        fi
        
        command=$(echo ${command}|tr -d '!')
    
        apply_patches "${command}"
        
        local result=${?}
    
        if ( [ ${result} -eq 0 ] && [ ${should_fail} -eq 0 ]) \
            || ([ ${result} -gt 0 ] && [ ${should_fail} -eq 1 ] \
        ) ; then
            continue
        fi

        return 1
    done
    
    if [ -d patches ] ; then
            for patch_file in $(find -L patches -type f) ; do
            local assertion=$(cat ${patch_file}|grep '@assert')
        
            assertions=$(echo "${assertion}"|cut -d' ' -f2)

            for assertion in ${assertions} ; do
                if assert ${assertion} ; then
                    continue
                fi
            
                assertion_error "${patch_file}" "${assertion}"
                        
                return 1
            done
        done
    fi
    
    IFS=${original_ifs}
    
    return 0
}

function apply_patches() {   
    local args=${1}
 
    local command="composer ${args} --ansi"
 
    eval "${command}; return \${PIPESTATUS[0]}"
    
    local result=${?}
    
    return ${result};
}

_info() {
    topic=${1}
    group=${2}
    label=${3}
    
    local separator=
    
    if [ "${group}" != '' ] ; then
        local separator=' - '
    fi

    echo "${grn}${1}${txtrst} ${brghtgrn}$(echo ${group}|tr '[:lower:]' '[:upper:]')${txtrst}${separator}${3}"
}

_title() {
    topic=${1}
    group=${2}
    label=${3}
    
    local separator=
    
    if [ "${group}" != '' ] ; then
        local separator=' - '
    fi

    echo "${cya}${1}${txtrst} ${brghtcya}$(echo ${group}|tr '[:lower:]' '[:upper:]')${txtrst}${separator}${3}"
}

_warning()
{
    echo "${bgdylw}${bldwht}${@}${txtrst}"
}

_error() {
    echo "${bgdred}${bldwht}${@}${txtrst}"
}

assert() {
    assertion=${1}
    invert=${2}

    local name=$(echo ${assertion}|cut -d',' -f1)
    local before=$(echo ${assertion}|cut -d',' -f2)
    local after=$(echo ${assertion}|cut -d',' -f3)

    local contents=$(cat vendor/${name}/src/example.txt)

    if [ "${invert}" != "" ] && [ "${invert}" != "0" ] ; then
        local tmp=${before}
        before=${after}
        after=${tmp}
    fi

    if echo "${contents}"|grep -qw "^${before}" && [ "${before}" == "${after}" ] ; then
        return 0
    fi
        
    if ! echo "${contents}"|grep -qw "^${before}" && echo "${contents}"|grep -qw "^${after}" ; then
        return 0
    fi
    
    return 1
}

assertion_error() {
    patch_file=${1}
    assertion=${2}
    invert=${3}

    local name=$(echo ${assertion}|cut -d',' -f1)
    local before=$(echo ${assertion}|cut -d',' -f2)
    local after=$(echo ${assertion}|cut -d',' -f3)

    local file=vendor/${name}/src/example.txt

    local contents=$(cat ${file})

    if [ "${invert}" != "" ] && [ "${invert}" != "0" ] ; then
        local tmp=${before}
        before=${after}
        after=${tmp}
    fi

    _error "PATCH: $(readlink -f ${patch_file})"
    _error "TARGET: ${file}"
    _error "ASSERTION: ${before} => ${after}"        
}

function reset_packages() {
    if [ -f vendor/composer/installed.json ] ; then
        sudo sed -i 's|\s"name":\s"vaimo/composer-patches-target\(.*\)",| \
            "name": "__vaimo/composer-patches-target\1",|g' \
            vendor/composer/installed.json
    fi
    
    composer install --ansi --no-plugins &>/dev/null
}

function sanitize() {
    rm -rf patches 2>/dev/null
    rm -rf modules 2>/dev/null
    rm -rf scenarios 2>/dev/null
    rm patches.json 2>/dev/null    
}

function sanitize_scenario() {    
    local scenario_root=${1}
    
    for dependency in $(ls -1 ${scenario_root}/files) ; do
        rm -rf ${dependency} 2>/dev/null   
    done 
}

function _line() {
    local character=${1}

    eval echo $(printf -- '${character}%.0s' {1..80})
}

function get_installation_root() {
    local installation_name=${1}

    (
        cd installations/${installation_name} &>/dev/null
        pwd
    )
}

scenario_filter=${1}

if echo "${scenario_filter}"|grep -q ':' ; then
    installation_filter=$(echo "${scenario_filter}"|cut -d':' -f1)
    scenario_filter=$(echo "${scenario_filter}"|cut -d':' -f2)
else 
    installation_filter=".*"
fi

if [ "${scenario_filter}" == "" ] ; then
    scenario_filter=".*"
fi

(
    cd test &>/dev/null
    
    sandbox_root=$(pwd)
    
    installations=$(ls installations -1)
    scenarios=$(ls scenarios -1)
    
    for installation in ${installations} ; do
        if ! echo ${installation}|grep -q "${installation_filter}" ; then
            continue
        fi
                
        installation_root=$(get_installation_root ${installation})

        installation_label=$(cat ${installation_root}/.label)
        scenarios_skip=$(cat ${installation_root}/.skip 2>/dev/null)
    
        _line '=' 80
        _title "INSTALLATION:" "${installation}" "${installation_label}"
        _line '=' 80
        
        (
            cd ${installation_root}
        
            sanitize

            ln -s ${sandbox_root}/modules ${installation_root}
            
            composer install --ansi --no-plugins
    
            for scenario in ${scenarios} ; do
                if [ "${scenarios_skip}" != "" ] && echo "${scenarios_skip}"|grep -q "^${scenario}$" ; then
                    continue
                fi
            
                if ! echo ${scenario}|grep -q "${scenario_filter}" ; then
                    continue
                fi
            
                scenario_root=${sandbox_root}/scenarios/${scenario}
            
                reset_packages
            
                if ! run_tests "${scenario_root}" ; then
                    sanitize
                    sanitize_scenario ${scenario_root}
                    exit 1
                else 
                    sanitize_scenario ${scenario_root}
                fi
            done
            
            echo ''
        
            sanitize
            
            exit 0
        )
        
        if [ ${?} != 0 ] ; then
            _line '"' 80
            _error "FAIL" 
            exit 1
        fi
    done

    _line 'â–š' 80
    _info "SUCCESS"
    
    exit 0    
)
